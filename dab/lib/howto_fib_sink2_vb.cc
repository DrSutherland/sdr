/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
 
 // Zürcher Hochschule für Angewandte Wissenschaften
 // Zentrum für Signalverarbeitung und Nachrichtentechnik
 // Michael Höin, 2011
 // info.zsn@zhaw.ch
 
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>

#include <howto_fib_sink2_vb.h>
#include <gr_io_signature.h>

howto_fib_sink2_vb_sptr 
howto_make_fib_sink2_vb ()
{
  return howto_fib_sink2_vb_sptr (new howto_fib_sink2_vb ());
}

howto_fib_sink2_vb::howto_fib_sink2_vb ()
  : gr_sync_block ("fib_sink2_vb",
      gr_make_io_signature (1, 1, sizeof (char)*240),
      gr_make_io_signature (0, 0, 0)),
      d_serviceLabel(),							// Array mit Servicelabels
      d_datenbank(),							// Array mit Datenbank der Services
      d_dateTime()								// Jahr/Monat/Tag/Stunde/Minute/Second/OffsetStunde/OffsetMinute
{
   memset(d_serviceLabel,' ',64*16);			// Service Label speicher
   
   memset(d_datenbank,0,64*8);					// Datenbank vorbereiten
   for(int i=0;i<64;i++) d_datenbank[i][0]=i+1;
   
   memset(d_dateTime,0,8);						// Zeit zuruecksetzen
   
}
//------------------------------------------------------------------------------------------
howto_fib_sink2_vb::~howto_fib_sink2_vb ()
{
  
}
//------------------------------------------------------------------------------------------
int 
howto_fib_sink2_vb::BinToDez(const char *FIG, int Offset, int laenge) 				// Binaer zu dezimal Rechnung
{
	int Value=0;
	for(int i=laenge-1;i>=0;i--) Value += ((int)FIG[i+Offset])*(1<<(laenge-1-i));
	return Value;
}
//------------------------------------------------------------------------------------------

void 
howto_fib_sink2_vb::Type1Extension1(const char *FIG, int Offset, int SId) 			// Senderbeschriftung anbringen
{
	for(int m=0;m<64;m++)
	{
		if (d_datenbank[m][1] == SId)												// Zugehoerigen Datenbankeintrag suchen
		{
			for(int i=0;i<16;i++)
			{
				char ByteValue=0;
				for(int r=7;r>=0;r--) ByteValue += (char)(((int)FIG[r+Offset])*(1<<(7-r)));
				Offset += 8;
				
				d_serviceLabel[m][i] = ByteValue;									// Labelname abspeichern
			}
		}
	}
}
//------------------------------------------------------------------------------------------

void 
howto_fib_sink2_vb::Type0Extension2(const char *FIG, int Offset, int BitLength)
{
	FIG += Offset;
	int PD = FIG[2];															// Programm or Data Service
	if(PD != 0) return;
	
	int pos = 8;																// Daten beginnen bei achtem Bit
	while (pos < BitLength)
	{
		int SId = BinToDez(FIG,pos,16);											// SId
		int NbrServComp = BinToDez(FIG,pos+20,4);								// Number of service components
		pos += 24;
		
		for (int k=0;k<NbrServComp;k++)											// Service Comp description durchlaufen
		{
			if(BinToDez(FIG,pos,2)==0)											// Nur TMId=00 beachten
			{
				int ASCTy = BinToDez(FIG,pos+2,6);								// Audiocodec
				int SubChId = BinToDez(FIG,pos+8,6);							// Subchannel ID Auslesen
				for(int m=0;m<64;m++)
				{
					if (d_datenbank[m][0] == SubChId)
					{
						d_datenbank[m][1] = SId;
						d_datenbank[m][7] = ASCTy;
					}
				}
			}
			pos += 16;
		}
	}
}

//------------------------------------------------------------------------------------------

void 
howto_fib_sink2_vb::Type0Extension1(const char *FIG, int Offset, int BitLength)
{
	// Tabelle ETSI EN 300 401 Page 50
   const int ProtLevel[64][3]   = {{16,5,32},	// Index 0
                                   {21,4,32},
                                   {24,3,32},
                                   {29,2,32},
                                   {35,1,32},	// Index 4
                                   {24,5,48},
                                   {29,4,48},
                                   {35,3,48},
                                   {42,2,48},
                                   {52,1,48},	// Index 9
                                   {29,5,56},
                                   {35,4,56},
                                   {42,3,56},
                                   {52,2,56},
                                   {32,5,64},	// Index 14
                                   {42,4,64},
                                   {48,3,64},
                                   {58,2,64},
                                   {70,1,64},
                                   {40,5,80},	// Index 19
                                   {52,4,80},
                                   {58,3,80},
                                   {70,2,80},
                                   {84,1,80},
                                   {48,5,96},	// Index 24
                                   {58,4,96},
                                   {70,3,96},
                                   {84,2,96},
                                   {104,1,96},
                                   {58,5,112},	// Index 29
                                   {70,4,112},
                                   {84,3,112},
                                   {104,2,112},
                                   {64,5,128},
                                   {84,4,128},	// Index 34
                                   {96,3,128},
                                   {116,2,128},
                                   {140,1,128},
                                   {80,5,160},
                                   {104,4,160},	// Index 39
                                   {116,3,160},
                                   {140,2,160},
                                   {168,1,160},
                                   {96,5,192},
                                   {116,4,192},	// Index 44
                                   {140,3,192},
                                   {168,2,192},
                                   {208,1,192},
                                   {116,5,224},
                                   {140,4,224},	// Index 49
                                   {168,3,224},
                                   {208,2,224},
                                   {232,1,224},
                                   {128,5,256},
                                   {168,4,256},	// Index 54
                                   {192,3,256},
                                   {232,2,256},
                                   {280,1,256},
                                   {160,5,320},
                                   {208,4,320},	// index 59
                                   {280,2,320},
                                   {192,5,384},
                                   {280,3,384},
                                   {416,1,384}};
                                   
	FIG += Offset;
	
	int pos = 8;																// Daten beginnen bei achtem Bit
	while (pos < BitLength)
	{
		int SubChId = BinToDez(FIG,pos,6);							// Subchannel ID auslesen
		int StartAdr = BinToDez(FIG,pos+6,10);						// Startadresse auslesen
		
		if(FIG[pos+16]==0)											// UEP
		{
			for(int m=0;m<64;m++)
			{
				if (d_datenbank[m][0] == SubChId)
				{
					d_datenbank[m][2] = StartAdr;					// Datenbank erweitern
					
					int TabelIndex = BinToDez(FIG,pos+18,6);		// Tabellen Index herauslesen
					d_datenbank[m][3] = ProtLevel[TabelIndex][0];	// Subchannel Size
					
					d_datenbank[m][4] = 0;							// UEP Sender
					
					d_datenbank[m][5] = ProtLevel[TabelIndex][1];	// Protection Level
					
					d_datenbank[m][6] = ProtLevel[TabelIndex][2];	// Bitrate
				}
			}
			pos += 24;
		}
		else 														// EEP
		{
			for(int m=0;m<64;m++)
			{
				if (d_datenbank[m][0] == SubChId)
				{
					d_datenbank[m][2] = StartAdr;					// Datenbank erweitern
					d_datenbank[m][4] = 1;							// EEP Sender
					
					int option = BinToDez(FIG,pos+17,3);			// Tabellen Index herauslesen
					if(option==0)									// Nur Proteciton EEP A programmiert
					{
						int PlusProtlevel = BinToDez(FIG,pos+20,2) + 1;
						d_datenbank[m][5] = PlusProtlevel;
						
						int SubChanSize = BinToDez(FIG,pos+22,10);
						d_datenbank[m][3] = SubChanSize;
						
						int DataRate;
						if(PlusProtlevel == 1) DataRate = SubChanSize /12 *8;
						if(PlusProtlevel == 2) DataRate = SubChanSize /8 *8;
						if(PlusProtlevel == 3) DataRate = SubChanSize /6 *8;
						if(PlusProtlevel == 4) DataRate = SubChanSize /4 *8;
						d_datenbank[m][6] = DataRate;
					}
				}
			}
			pos += 32;
		}
	}
}
//------------------------------------------------------------------------------------------
void 
howto_fib_sink2_vb::Type0Extension10(const char *FIG, int Offset)			// UTC auslesen
{
	FIG += Offset;
	
	int pos = 8;																// Daten beginnen bei achtem Bit
	int mjd = BinToDez(FIG,pos+1,17);
	
	int J = mjd + 2400001;											// Modified Julian Date umrechnen (Nach wikipedia)
	int j = J + 32044;
	int g = j / 146097; 
	int dg = j%146097;
	int c = ((dg / 36524) + 1) * 3 / 4; 
	int dc = dg - c * 36524;
	int b = dc / 1461;
	int db = dc%1461;
	int a = ((db / 365) + 1) * 3 / 4; 
	int da = db - a * 365;
	int y = g * 400 + c * 100 + b * 4 + a;
	int m = ((da * 5 + 308) / 153) - 2;
	int d = da - ((m + 4) * 153 / 5) + 122;
	int Y = y - 4800 + ((m + 2) / 12); 
	int M = ((m + 2)%12)+1; 
	int D = d + 1;
	
	d_dateTime[0] = Y;											// Jahr
	d_dateTime[1] = M;											// Monat
	d_dateTime[2] = D;											// Tag
	d_dateTime[3] = BinToDez(FIG,pos+21,5);						// Stunden
	if (BinToDez(FIG,pos+26,6) != d_dateTime[4])
	{
		d_dateTime[5]= 0;										// Sekunden (Uebergang abfangen)
	}
	d_dateTime[4] = BinToDez(FIG,pos+26,6);						// Minuten
	if(FIG[pos+20]) d_dateTime[5]= BinToDez(FIG,pos+32,6);		// Sekunden
}
//------------------------------------------------------------------------------------------
void 
howto_fib_sink2_vb::Type0Extension9(const char *FIG, int Offset)			// UTC auslesen
{
	FIG += Offset;
	int pos = 8;															// Daten beginnen bei achtem Bit
	
	d_dateTime[6] = (FIG[pos+2]==1)? -1*BinToDez(FIG,pos+3,4):BinToDez(FIG,pos+3,4);
	d_dateTime[7] = (FIG[pos+7]==1)? 30:0;
}
//------------------------------------------------------------------------------------------
int 
howto_fib_sink2_vb::work (int noutput_items,
                         gr_vector_const_void_star &input_items,
                         gr_vector_void_star &output_items)
{
	const char *in = (const char *) input_items[0];

	unsigned int input_used_counter = 0;					// Verbrauchte Inputvektoren zaehlen
	
//------------------------------------------------------------------------------------------
	unsigned int block,i;									// Schleifenvariable
	unsigned int bitCounter;								// Bitcounter
	char Summe;												// Summe um das Endflag zu finden
	int Type;												// FIG Type
	int Length;												// FIG Length
	int Extension;											// FIG Extension
//------------------------------------------------------------------------------------------

	for (int block = 0; block < noutput_items; block++)
	{
		
		bitCounter = 0;
		while(bitCounter<240)
		{
			Summe=0;													// Endflag ueberpruefen
			for(i=0;i<8;i++) Summe+=in[bitCounter+i];
			if(Summe==8) break;
			
			Type = BinToDez(in,bitCounter,3);							// FIG Header auswerten
			Length = BinToDez(in,bitCounter+3,5);
			bitCounter+=8;
			
			Extension = BinToDez(in,bitCounter+3,5);					// FIG Datenfield verarbeiten
			
			if((Type == 1) && (Extension == 1)) Type1Extension1(in, bitCounter+24, BinToDez(in,bitCounter+8,16));	// Service Labels
			if((Type == 0) && (Extension == 2)) Type0Extension2(in, bitCounter, Length*8);							// Subchannel Informations
			if((Type == 0) && (Extension == 1)) Type0Extension1(in, bitCounter, Length*8);							// Channel Informations
			if((Type == 0) && (Extension == 10)) Type0Extension10(in, bitCounter);									// UTC
			if((Type == 0) && (Extension == 9)) Type0Extension9(in, bitCounter);									// LTO
		
			bitCounter += Length*8;
		}
		in+=240;
	}
	
	// -----------------------------------------------------------------
	// Print aller Daten
	// -----------------------------------------------------------------
	
	// Zeit
	// Jahr/Monat/Tag/Stunde/Minute/Second/OffsetStunde/OffsetMinute
	printf("Ensemble-Time: %4d/%02d/%02d %02d:%02d:%02d %+03d:%02d\n",
	         d_dateTime[0],d_dateTime[1],d_dateTime[2],d_dateTime[3],d_dateTime[4],d_dateTime[5],d_dateTime[6],d_dateTime[7]);
	
	// Serviceinfos
	for (int m=0; m<64; m++)
	{
		if (d_datenbank[m][1] == 0) continue;
		for (int f=0;f<16;f++) printf("%1c", d_serviceLabel[m][f]);
		if (d_datenbank[m][4]==1)
		printf(" SubChan: %2d SId: %5d StartAdr: %3d Size: %3d EEP: %1d Level: %1d-A kbit/s: %3d ASCTy: %2d \n",
		                                             d_datenbank[m][0],d_datenbank[m][1],d_datenbank[m][2],d_datenbank[m][3],
		                                             d_datenbank[m][4],d_datenbank[m][5],d_datenbank[m][6],d_datenbank[m][7]);
		else
		printf(" SubChan: %2d SId: %5d StartAdr: %3d Size: %3d EEP: %1d Level: %1d   kbit/s: %3d ASCTy: %2d \n",
		                                             d_datenbank[m][0],d_datenbank[m][1],d_datenbank[m][2],d_datenbank[m][3],
		                                             d_datenbank[m][4],d_datenbank[m][5],d_datenbank[m][6],d_datenbank[m][7]);
	}
	printf("\n");

	return noutput_items;							// Anzahl Outputdaten
}
